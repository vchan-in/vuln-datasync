// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: vulnerabilities.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchUpsertVulnerabilitiesParams struct {
	ID               string             `json:"id"`
	Summary          pgtype.Text        `json:"summary"`
	Details          pgtype.Text        `json:"details"`
	Severity         pgtype.Text        `json:"severity"`
	PublishedAt      pgtype.Timestamptz `json:"published_at"`
	ModifiedAt       pgtype.Timestamptz `json:"modified_at"`
	Ecosystem        pgtype.Text        `json:"ecosystem"`
	PackageName      pgtype.Text        `json:"package_name"`
	AffectedVersions []string           `json:"affected_versions"`
	FixedVersions    []string           `json:"fixed_versions"`
	Aliases          []string           `json:"aliases"`
	Refs             []byte             `json:"refs"`
	Source           []string           `json:"source"`
	Raw              []byte             `json:"raw"`
	DataHash         pgtype.Text        `json:"data_hash"`
}

const countVulnerabilities = `-- name: CountVulnerabilities :one
SELECT COUNT(*) FROM vulnerabilities
`

func (q *Queries) CountVulnerabilities(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countVulnerabilities)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVulnerabilitiesByEcosystem = `-- name: CountVulnerabilitiesByEcosystem :many
SELECT ecosystem, COUNT(*) as count
FROM vulnerabilities 
WHERE ecosystem IS NOT NULL
GROUP BY ecosystem
ORDER BY count DESC
`

type CountVulnerabilitiesByEcosystemRow struct {
	Ecosystem pgtype.Text `json:"ecosystem"`
	Count     int64       `json:"count"`
}

func (q *Queries) CountVulnerabilitiesByEcosystem(ctx context.Context) ([]CountVulnerabilitiesByEcosystemRow, error) {
	rows, err := q.db.Query(ctx, countVulnerabilitiesByEcosystem)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountVulnerabilitiesByEcosystemRow{}
	for rows.Next() {
		var i CountVulnerabilitiesByEcosystemRow
		if err := rows.Scan(&i.Ecosystem, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countVulnerabilitiesBySource = `-- name: CountVulnerabilitiesBySource :many
SELECT 
    unnest(source) as source_name,
    COUNT(*) as count
FROM vulnerabilities 
GROUP BY source_name
ORDER BY count DESC
`

type CountVulnerabilitiesBySourceRow struct {
	SourceName interface{} `json:"source_name"`
	Count      int64       `json:"count"`
}

func (q *Queries) CountVulnerabilitiesBySource(ctx context.Context) ([]CountVulnerabilitiesBySourceRow, error) {
	rows, err := q.db.Query(ctx, countVulnerabilitiesBySource)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountVulnerabilitiesBySourceRow{}
	for rows.Next() {
		var i CountVulnerabilitiesBySourceRow
		if err := rows.Scan(&i.SourceName, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createVulnerability = `-- name: CreateVulnerability :one
INSERT INTO vulnerabilities (
    id, summary, details, severity, published_at, modified_at,
    ecosystem, package_name, affected_versions, fixed_versions,
    aliases, refs, source, raw, data_hash
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING id, summary, details, severity, published_at, modified_at, ecosystem, package_name, affected_versions, fixed_versions, aliases, refs, source, raw, data_hash, created_at, updated_at
`

type CreateVulnerabilityParams struct {
	ID               string             `json:"id"`
	Summary          pgtype.Text        `json:"summary"`
	Details          pgtype.Text        `json:"details"`
	Severity         pgtype.Text        `json:"severity"`
	PublishedAt      pgtype.Timestamptz `json:"published_at"`
	ModifiedAt       pgtype.Timestamptz `json:"modified_at"`
	Ecosystem        pgtype.Text        `json:"ecosystem"`
	PackageName      pgtype.Text        `json:"package_name"`
	AffectedVersions []string           `json:"affected_versions"`
	FixedVersions    []string           `json:"fixed_versions"`
	Aliases          []string           `json:"aliases"`
	Refs             []byte             `json:"refs"`
	Source           []string           `json:"source"`
	Raw              []byte             `json:"raw"`
	DataHash         pgtype.Text        `json:"data_hash"`
}

func (q *Queries) CreateVulnerability(ctx context.Context, arg CreateVulnerabilityParams) (Vulnerability, error) {
	row := q.db.QueryRow(ctx, createVulnerability,
		arg.ID,
		arg.Summary,
		arg.Details,
		arg.Severity,
		arg.PublishedAt,
		arg.ModifiedAt,
		arg.Ecosystem,
		arg.PackageName,
		arg.AffectedVersions,
		arg.FixedVersions,
		arg.Aliases,
		arg.Refs,
		arg.Source,
		arg.Raw,
		arg.DataHash,
	)
	var i Vulnerability
	err := row.Scan(
		&i.ID,
		&i.Summary,
		&i.Details,
		&i.Severity,
		&i.PublishedAt,
		&i.ModifiedAt,
		&i.Ecosystem,
		&i.PackageName,
		&i.AffectedVersions,
		&i.FixedVersions,
		&i.Aliases,
		&i.Refs,
		&i.Source,
		&i.Raw,
		&i.DataHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVulnerability = `-- name: DeleteVulnerability :exec
DELETE FROM vulnerabilities WHERE id = $1
`

func (q *Queries) DeleteVulnerability(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteVulnerability, id)
	return err
}

const getRecentVulnerabilities = `-- name: GetRecentVulnerabilities :many
SELECT id, summary, details, severity, published_at, modified_at, ecosystem, package_name, affected_versions, fixed_versions, aliases, refs, source, raw, data_hash, created_at, updated_at FROM vulnerabilities 
WHERE created_at >= $1
ORDER BY created_at DESC
LIMIT $2
`

type GetRecentVulnerabilitiesParams struct {
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Limit     int32              `json:"limit"`
}

func (q *Queries) GetRecentVulnerabilities(ctx context.Context, arg GetRecentVulnerabilitiesParams) ([]Vulnerability, error) {
	rows, err := q.db.Query(ctx, getRecentVulnerabilities, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vulnerability{}
	for rows.Next() {
		var i Vulnerability
		if err := rows.Scan(
			&i.ID,
			&i.Summary,
			&i.Details,
			&i.Severity,
			&i.PublishedAt,
			&i.ModifiedAt,
			&i.Ecosystem,
			&i.PackageName,
			&i.AffectedVersions,
			&i.FixedVersions,
			&i.Aliases,
			&i.Refs,
			&i.Source,
			&i.Raw,
			&i.DataHash,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpdatedVulnerabilities = `-- name: GetUpdatedVulnerabilities :many
SELECT id, summary, details, severity, published_at, modified_at, ecosystem, package_name, affected_versions, fixed_versions, aliases, refs, source, raw, data_hash, created_at, updated_at FROM vulnerabilities 
WHERE updated_at >= $1
ORDER BY updated_at DESC
LIMIT $2
`

type GetUpdatedVulnerabilitiesParams struct {
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	Limit     int32              `json:"limit"`
}

func (q *Queries) GetUpdatedVulnerabilities(ctx context.Context, arg GetUpdatedVulnerabilitiesParams) ([]Vulnerability, error) {
	rows, err := q.db.Query(ctx, getUpdatedVulnerabilities, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vulnerability{}
	for rows.Next() {
		var i Vulnerability
		if err := rows.Scan(
			&i.ID,
			&i.Summary,
			&i.Details,
			&i.Severity,
			&i.PublishedAt,
			&i.ModifiedAt,
			&i.Ecosystem,
			&i.PackageName,
			&i.AffectedVersions,
			&i.FixedVersions,
			&i.Aliases,
			&i.Refs,
			&i.Source,
			&i.Raw,
			&i.DataHash,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVulnerabilitiesByAliases = `-- name: GetVulnerabilitiesByAliases :many
SELECT id, summary, details, severity, published_at, modified_at, ecosystem, package_name, affected_versions, fixed_versions, aliases, refs, source, raw, data_hash, created_at, updated_at FROM vulnerabilities WHERE aliases && $1::text[]
`

func (q *Queries) GetVulnerabilitiesByAliases(ctx context.Context, dollar_1 []string) ([]Vulnerability, error) {
	rows, err := q.db.Query(ctx, getVulnerabilitiesByAliases, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vulnerability{}
	for rows.Next() {
		var i Vulnerability
		if err := rows.Scan(
			&i.ID,
			&i.Summary,
			&i.Details,
			&i.Severity,
			&i.PublishedAt,
			&i.ModifiedAt,
			&i.Ecosystem,
			&i.PackageName,
			&i.AffectedVersions,
			&i.FixedVersions,
			&i.Aliases,
			&i.Refs,
			&i.Source,
			&i.Raw,
			&i.DataHash,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVulnerabilitiesByEcosystem = `-- name: GetVulnerabilitiesByEcosystem :many
SELECT id, summary, details, severity, published_at, modified_at, ecosystem, package_name, affected_versions, fixed_versions, aliases, refs, source, raw, data_hash, created_at, updated_at FROM vulnerabilities 
WHERE ecosystem = $1
ORDER BY published_at DESC
LIMIT $2 OFFSET $3
`

type GetVulnerabilitiesByEcosystemParams struct {
	Ecosystem pgtype.Text `json:"ecosystem"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) GetVulnerabilitiesByEcosystem(ctx context.Context, arg GetVulnerabilitiesByEcosystemParams) ([]Vulnerability, error) {
	rows, err := q.db.Query(ctx, getVulnerabilitiesByEcosystem, arg.Ecosystem, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vulnerability{}
	for rows.Next() {
		var i Vulnerability
		if err := rows.Scan(
			&i.ID,
			&i.Summary,
			&i.Details,
			&i.Severity,
			&i.PublishedAt,
			&i.ModifiedAt,
			&i.Ecosystem,
			&i.PackageName,
			&i.AffectedVersions,
			&i.FixedVersions,
			&i.Aliases,
			&i.Refs,
			&i.Source,
			&i.Raw,
			&i.DataHash,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVulnerabilitiesByPackage = `-- name: GetVulnerabilitiesByPackage :many
SELECT id, summary, details, severity, published_at, modified_at, ecosystem, package_name, affected_versions, fixed_versions, aliases, refs, source, raw, data_hash, created_at, updated_at FROM vulnerabilities 
WHERE ecosystem = $1 AND package_name = $2
ORDER BY published_at DESC
LIMIT $3 OFFSET $4
`

type GetVulnerabilitiesByPackageParams struct {
	Ecosystem   pgtype.Text `json:"ecosystem"`
	PackageName pgtype.Text `json:"package_name"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

func (q *Queries) GetVulnerabilitiesByPackage(ctx context.Context, arg GetVulnerabilitiesByPackageParams) ([]Vulnerability, error) {
	rows, err := q.db.Query(ctx, getVulnerabilitiesByPackage,
		arg.Ecosystem,
		arg.PackageName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vulnerability{}
	for rows.Next() {
		var i Vulnerability
		if err := rows.Scan(
			&i.ID,
			&i.Summary,
			&i.Details,
			&i.Severity,
			&i.PublishedAt,
			&i.ModifiedAt,
			&i.Ecosystem,
			&i.PackageName,
			&i.AffectedVersions,
			&i.FixedVersions,
			&i.Aliases,
			&i.Refs,
			&i.Source,
			&i.Raw,
			&i.DataHash,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVulnerabilityByAlias = `-- name: GetVulnerabilityByAlias :one
SELECT id, summary, details, severity, published_at, modified_at, ecosystem, package_name, affected_versions, fixed_versions, aliases, refs, source, raw, data_hash, created_at, updated_at FROM vulnerabilities WHERE $1 = ANY(aliases) LIMIT 1
`

func (q *Queries) GetVulnerabilityByAlias(ctx context.Context, aliases []string) (Vulnerability, error) {
	row := q.db.QueryRow(ctx, getVulnerabilityByAlias, aliases)
	var i Vulnerability
	err := row.Scan(
		&i.ID,
		&i.Summary,
		&i.Details,
		&i.Severity,
		&i.PublishedAt,
		&i.ModifiedAt,
		&i.Ecosystem,
		&i.PackageName,
		&i.AffectedVersions,
		&i.FixedVersions,
		&i.Aliases,
		&i.Refs,
		&i.Source,
		&i.Raw,
		&i.DataHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVulnerabilityByDataHash = `-- name: GetVulnerabilityByDataHash :one
SELECT id, summary, details, severity, published_at, modified_at, ecosystem, package_name, affected_versions, fixed_versions, aliases, refs, source, raw, data_hash, created_at, updated_at FROM vulnerabilities WHERE data_hash = $1
`

func (q *Queries) GetVulnerabilityByDataHash(ctx context.Context, dataHash pgtype.Text) (Vulnerability, error) {
	row := q.db.QueryRow(ctx, getVulnerabilityByDataHash, dataHash)
	var i Vulnerability
	err := row.Scan(
		&i.ID,
		&i.Summary,
		&i.Details,
		&i.Severity,
		&i.PublishedAt,
		&i.ModifiedAt,
		&i.Ecosystem,
		&i.PackageName,
		&i.AffectedVersions,
		&i.FixedVersions,
		&i.Aliases,
		&i.Refs,
		&i.Source,
		&i.Raw,
		&i.DataHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVulnerabilityByID = `-- name: GetVulnerabilityByID :one
SELECT id, summary, details, severity, published_at, modified_at, ecosystem, package_name, affected_versions, fixed_versions, aliases, refs, source, raw, data_hash, created_at, updated_at FROM vulnerabilities WHERE id = $1
`

func (q *Queries) GetVulnerabilityByID(ctx context.Context, id string) (Vulnerability, error) {
	row := q.db.QueryRow(ctx, getVulnerabilityByID, id)
	var i Vulnerability
	err := row.Scan(
		&i.ID,
		&i.Summary,
		&i.Details,
		&i.Severity,
		&i.PublishedAt,
		&i.ModifiedAt,
		&i.Ecosystem,
		&i.PackageName,
		&i.AffectedVersions,
		&i.FixedVersions,
		&i.Aliases,
		&i.Refs,
		&i.Source,
		&i.Raw,
		&i.DataHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVulnerabilityStats = `-- name: GetVulnerabilityStats :one
SELECT total_vulnerabilities, osv_count, gitlab_count, cve_count, merged_count, ecosystem_count, package_count, oldest_vulnerability, newest_vulnerability, last_updated FROM vulnerability_stats
`

func (q *Queries) GetVulnerabilityStats(ctx context.Context) (VulnerabilityStat, error) {
	row := q.db.QueryRow(ctx, getVulnerabilityStats)
	var i VulnerabilityStat
	err := row.Scan(
		&i.TotalVulnerabilities,
		&i.OsvCount,
		&i.GitlabCount,
		&i.CveCount,
		&i.MergedCount,
		&i.EcosystemCount,
		&i.PackageCount,
		&i.OldestVulnerability,
		&i.NewestVulnerability,
		&i.LastUpdated,
	)
	return i, err
}

const updateVulnerability = `-- name: UpdateVulnerability :one
UPDATE vulnerabilities SET
    summary = $2,
    details = $3,
    severity = $4,
    published_at = $5,
    modified_at = $6,
    ecosystem = $7,
    package_name = $8,
    affected_versions = $9,
    fixed_versions = $10,
    aliases = $11,
    refs = $12,
    source = $13,
    raw = $14,
    data_hash = $15,
    updated_at = NOW()
WHERE id = $1
RETURNING id, summary, details, severity, published_at, modified_at, ecosystem, package_name, affected_versions, fixed_versions, aliases, refs, source, raw, data_hash, created_at, updated_at
`

type UpdateVulnerabilityParams struct {
	ID               string             `json:"id"`
	Summary          pgtype.Text        `json:"summary"`
	Details          pgtype.Text        `json:"details"`
	Severity         pgtype.Text        `json:"severity"`
	PublishedAt      pgtype.Timestamptz `json:"published_at"`
	ModifiedAt       pgtype.Timestamptz `json:"modified_at"`
	Ecosystem        pgtype.Text        `json:"ecosystem"`
	PackageName      pgtype.Text        `json:"package_name"`
	AffectedVersions []string           `json:"affected_versions"`
	FixedVersions    []string           `json:"fixed_versions"`
	Aliases          []string           `json:"aliases"`
	Refs             []byte             `json:"refs"`
	Source           []string           `json:"source"`
	Raw              []byte             `json:"raw"`
	DataHash         pgtype.Text        `json:"data_hash"`
}

func (q *Queries) UpdateVulnerability(ctx context.Context, arg UpdateVulnerabilityParams) (Vulnerability, error) {
	row := q.db.QueryRow(ctx, updateVulnerability,
		arg.ID,
		arg.Summary,
		arg.Details,
		arg.Severity,
		arg.PublishedAt,
		arg.ModifiedAt,
		arg.Ecosystem,
		arg.PackageName,
		arg.AffectedVersions,
		arg.FixedVersions,
		arg.Aliases,
		arg.Refs,
		arg.Source,
		arg.Raw,
		arg.DataHash,
	)
	var i Vulnerability
	err := row.Scan(
		&i.ID,
		&i.Summary,
		&i.Details,
		&i.Severity,
		&i.PublishedAt,
		&i.ModifiedAt,
		&i.Ecosystem,
		&i.PackageName,
		&i.AffectedVersions,
		&i.FixedVersions,
		&i.Aliases,
		&i.Refs,
		&i.Source,
		&i.Raw,
		&i.DataHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertVulnerability = `-- name: UpsertVulnerability :one
INSERT INTO vulnerabilities (
    id, summary, details, severity, published_at, modified_at,
    ecosystem, package_name, affected_versions, fixed_versions,
    aliases, refs, source, raw, data_hash
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) 
ON CONFLICT (id) DO UPDATE SET
    summary = EXCLUDED.summary,
    details = EXCLUDED.details,
    severity = EXCLUDED.severity,
    published_at = EXCLUDED.published_at,
    modified_at = EXCLUDED.modified_at,
    ecosystem = EXCLUDED.ecosystem,
    package_name = EXCLUDED.package_name,
    affected_versions = EXCLUDED.affected_versions,
    fixed_versions = EXCLUDED.fixed_versions,
    aliases = EXCLUDED.aliases,
    refs = EXCLUDED.refs,
    source = EXCLUDED.source,
    raw = EXCLUDED.raw,
    data_hash = EXCLUDED.data_hash,
    updated_at = NOW()
RETURNING id, summary, details, severity, published_at, modified_at, ecosystem, package_name, affected_versions, fixed_versions, aliases, refs, source, raw, data_hash, created_at, updated_at
`

type UpsertVulnerabilityParams struct {
	ID               string             `json:"id"`
	Summary          pgtype.Text        `json:"summary"`
	Details          pgtype.Text        `json:"details"`
	Severity         pgtype.Text        `json:"severity"`
	PublishedAt      pgtype.Timestamptz `json:"published_at"`
	ModifiedAt       pgtype.Timestamptz `json:"modified_at"`
	Ecosystem        pgtype.Text        `json:"ecosystem"`
	PackageName      pgtype.Text        `json:"package_name"`
	AffectedVersions []string           `json:"affected_versions"`
	FixedVersions    []string           `json:"fixed_versions"`
	Aliases          []string           `json:"aliases"`
	Refs             []byte             `json:"refs"`
	Source           []string           `json:"source"`
	Raw              []byte             `json:"raw"`
	DataHash         pgtype.Text        `json:"data_hash"`
}

func (q *Queries) UpsertVulnerability(ctx context.Context, arg UpsertVulnerabilityParams) (Vulnerability, error) {
	row := q.db.QueryRow(ctx, upsertVulnerability,
		arg.ID,
		arg.Summary,
		arg.Details,
		arg.Severity,
		arg.PublishedAt,
		arg.ModifiedAt,
		arg.Ecosystem,
		arg.PackageName,
		arg.AffectedVersions,
		arg.FixedVersions,
		arg.Aliases,
		arg.Refs,
		arg.Source,
		arg.Raw,
		arg.DataHash,
	)
	var i Vulnerability
	err := row.Scan(
		&i.ID,
		&i.Summary,
		&i.Details,
		&i.Severity,
		&i.PublishedAt,
		&i.ModifiedAt,
		&i.Ecosystem,
		&i.PackageName,
		&i.AffectedVersions,
		&i.FixedVersions,
		&i.Aliases,
		&i.Refs,
		&i.Source,
		&i.Raw,
		&i.DataHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
